\chapter{Developer documentation}
This chapter is for potential developers of the project.

\section{Project building and testing}
The project has two ways of building. One way is through Makefile and the second through Cabal. 
By running the following command it generates the build folder and lsql-csv binary under it.
\begin{verbatim}
make
\end{verbatim}
 
It is necessary to have all Haskell dependencies (\icode{Parsec} ($\geq 3.1$ $<3.2$), \icode{Glob} ($\geq 0.10$ $<0.11$), 
\icode{base} ($\geq 4.9$ $<4.20$), \icode{text} ($\geq 1.2$ $<1.3$) and \icode{containers} ($\geq 0.5$ $<0.7$)) installed.
The package boundaries given are identical to cabal boundaries. Also, it is necessary, that you have \icode{GHC} ($\geq 8 <9.29$) installed.

The second way of building is through cabal, which handles all dependencies for you.

\begin{verbatim}
cabal build
\end{verbatim}


The project unit tests require building through \icode{Makefile} and is called by:
\begin{verbatim}
make test
\end{verbatim}
It should always succeed before any commit is made.

It is possible to generate Haddock developer documentation by calling:
\begin{verbatim}
cabal haddock
\end{verbatim}

The documentation contains comments on all exported functions. The documentation can be alternatively generated
by running:

\begin{verbatim}
make docs
\end{verbatim}
It generates html documentation under the build folder.

The package is also published at \url{https://hackage.haskell.org/package/lsql-csv} in Hackage public repository. 
The generated documentation is fully browseable there.

\section{\icode{String} vs \icode{Data.Text}}
As there is a long-term discussion in the Haskell community about whether \icode{String} or \icode{Data.Text} should be used as the 
primary representation of text, I would like to emphasize that in this project, String is used as a primary
representation for text.

\section{Project layout}

The project is split into:
\begin{enumerate}
  \item a library, which contains almost all the logic and is placed under
       \icode{src} folder of the project

  \item the \icode{main}, which contains one source file
      with \icode{Main}, which is the entry point for \icode{lsql-csv} binary. 
      It parses the arguments, and checks, whether the help optional argument was called or no argument at all was given, 
      and either shows help or further call run from \icode{Lsql.Csv.Main} from the library.
\end{enumerate}

The library is split into 5 different namespaces. Its usage is not strictly defined, but this can be said
\begin{itemize}
    \item \icode{Lsql.Csv} -- This namespace contains the entry point
    \item \icode{Lsql.Csv.Core} -- This namespace contains the logic of evaluation
    \item \icode{Lsql.Csv.Lang} -- This namespace contains parsers
    \item \icode{Lsql.Csv.Lang.From} -- This namespace cointains parsers for the from block
    \item \icode{Lsql.Csv.Utils} -- This namespace contains helper functions
\end{itemize}

\section{Modules}
The following section is a summary of all modules of the library.
\begin{itemize}
    \item \icode{Lsql.Csv.Core.BlockOps} -- This module contains the \icode{Block} definition and functions for getting specific types of blocks from the list of \icode{Block}.
    \item \icode{Lsql.Csv.Core.Evaluator} -- This module contains the evaluator of \icode{lsql-csv} program.
    \item \icode{Lsql.Csv.Core.Functions} -- This module contains the syntactic tree definition and helper functions for its evaluation.
    \item \icode{Lsql.Csv.Core.Symbols} -- This module contains the definition of \icode{Symbol}, \icode{SymbolMap} and helper functions.
    \item \icode{Lsql.Csv.Core.Tables} -- This module contains the definition of \icode{lsql-csv} 
        data types, classes over them, and types \icode{Table} and \icode{Column} and functions over them for manipulation of them.
    \item \icode{Lsql.Csv.Lang.Args} -- A module for command line argument parsing.
    \item \icode{Lsql.Csv.Lang.BlockChain} -- This module contains a main parser of blocks other than the from block.
    \item \icode{Lsql.Csv.Lang.BlockSeparator} -- This module contains a preprocessor parser, which splits the command into a list of strings - one string per one block.
    \item \icode{Lsql.Csv.Lang.Options} -- This module implements a common \icode{Option} type and its parsers for from blocks and command line optional arguments.
    \item \icode{Lsql.Csv.Lang.Selector} -- This module implements the selector expression and arithmetic expression parsers.
    \item \icode{Lsql.Csv.Lang.From.Block} -- This module contains the from block parser. It loads the initial \icode{SymbolMap}.
    \item \icode{Lsql.Csv.Lang.From.CsvParser} -- This module contains \icode{CsvParser} called by \icode{parseFile}, which loads input CSV files.
    \item \icode{Lsql.Csv.Main} -- This module contains the starting point for \icode{lsql-csv} evaluation.
    \item \icode{Lsql.Csv.Utils.BracketExpansion} -- This module contains the curly bracket (braces) expansion implementation.
    \item \icode{Lsql.Csv.Utils.CsvGenerator} -- This module contains the CSV generator for the output.
\end{itemize}

\section{Entry point}
The entry point is in module \icode{Lsql.Csv.Main} in function \icode{run}. 
The function first calls preprocesor in \icode{Lsql.Csv.Lang.BlockSeparator}, which splits command into list of strings. Then \icode{SymbolMap} with input is loaded using \icode{Lsql.Csv.Lang.From.Block} and after that
rest of blocks are parsed using \icode{Lsql.Csv.Lang.BlockChain}. Program is then evaluated using
\icode{Lsql.Csv.Core.Evaluator} and finally output generated by \icode{Lsql.Csv.Utils.CsvGenerator}.



